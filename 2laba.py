'''Разработать систему решения нелинейных уравнений 3 методами:
 методом дихотоимей, методом простых итераций, методом ньютона.
 Функции:
 def dihotomia(a, b, e):Функция для метода дихотомии.
 Ищет корень уравнения y1(x) на отрезке [a, b] с заданной точностью e
 def simple_iteration(x0, e, iterations): Функция для метода простых итераций.
 Находит корень уравнения методом итераций, начиная с начального приближения x0 с заданной точностью e и числом итераций
 def newton_method(x0, e):Функция для метода Ньютона.
Использует метод Ньютона для нахождения корня уравнения с начальным приближением и заданной точностью e
Переменные
Афонина Анна, Сукерт Милена ИСТ-22-1б'''

def y1(x):
    # Функция, которая возвращает значение уравнения x^2 - 2 для заданного значения x
    return x**2 - 2

def g1(x):
    # Функция g(x), где g(x) = (x^2+2)/(2*x) эквивалентна функции y1(x)
    return (x**2 + 2) / (2 * x)

def d1(x):
    # Производная функции y1(x)
    return 2 * x

def dihotomia(a, b, e):
    if y1(a) * y1(b) > 0:  # Проверка знаков на концах интервала
        print("Нет корня на этом интервале")  # Вывод сообщения, если корня нет на данном интервале
        return None  # Возвращаем None, так как корень не существует
    else:
        while abs(b - a) > e:  # Пока разница между концами интервала больше точности e
            c = (a + b) / 2.0  # Находим середину интервала
            if y1(a) * y1(c) <= 0:  # Если знаки разные на a и c
                b = c  # Сдвигаем правую границу интервала
            else:
                a = c  # Сдвигаем левую границу интервала
        return (a + b) / 2  # Возвращаем найденный корень

def simple_iteration(x0, e, iterations):
    x = x0  # Начальное приближение для итераций
    n = 0  # Счетчик итераций
    while n < iterations:  # Пока не достигнуто заданное число итераций
        x1 = g1(x)  # Вычисляем следующее приближение
        delta = abs(x1 - x)  # Вычисляем разницу между текущим и предыдущим приближениями
        if delta <= e:  # Если достигнута необходимая точность
            return (x, n)  # Возвращаем найденный корень и число итераций, на котором он был найден
        x = x1  # Переходим к следующему приближению
        n += 1  # Увеличиваем счетчик итераций

def newton_method(x0, e):
    n = 1  # Счетчик итераций, начальное значение
    x = x0  # Переменная для хранения текущего приближенного значения корня
    while abs(x - x0) >= e:  # Пока разница между текущим и предыдущим приближенными корнями больше или равна заданной точности
        y11 = y1(x0)  # Вычисляем значение функции в точке x0
        y12 = d1(x0)  # Вычисляем значение производной функции в точке x0
        x = x0 - y11 / y12  # Вычисляем новое приближенное значение корня по методу Ньютона
        x0 = x  # Обновляем x0 для следующей итерации
        n = n + 1  # Увеличиваем счетчик итераций
    x1 = x  # Найденное приближенное значение корня
    y = y1(x1)  # Значение функции в найденном корне
    return (n, x1, y)  # Возвращаем число итераций, найденный корень и значение функции в этом корне

def main():
    x0 = 1.5
    e = 1e-6
    iterations = 1000
    a = 1
    b = 3
    root1 = dihotomia(a, b, e)
    print(f"Приближенный корень дихотомией:", root1)
    root2 = simple_iteration(x0, e, iterations)
    print(f"Приближенный корень по методу простых итераций:", root2)
    root3 = newton_method(x0, e)
    print(f"Приближенный корень по методу Ньютона:", root3)

if __name__ == "__main__":
    main()
